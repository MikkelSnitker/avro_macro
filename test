#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use std::{
    fmt::format, io::{Read, Write},
    time,
};
use apache_avro::{schema, AvroSchema};
use avro_macro::{schema, TaggedEnum};
use serde::{
    de::{self, value},
    ser::{self, SerializeSeq, SerializeTupleVariant},
    Deserialize, Serialize,
};
mod Test {
    use serde::{Deserialize, Serialize};
    pub mod test {
        pub struct WishCreatedMetadata {
            #[avro(rename = "id")]
            #[serde(rename = "id")]
            pub id: String,
            #[avro(rename = "productId")]
            #[serde(rename = "productId")]
            pub product_id: Option<String>,
            #[avro(rename = "productListId")]
            #[serde(rename = "productListId")]
            pub product_list_id: Option<String>,
            #[avro(rename = "productListPosition")]
            #[serde(rename = "productListPosition")]
            pub product_list_position: Option<Vec<String>>,
            #[avro(rename = "productPosition")]
            #[serde(rename = "productPosition")]
            pub product_position: Option<Vec<String>>,
            #[avro(rename = "source")]
            #[serde(rename = "source")]
            pub source: Option<String>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for WishCreatedMetadata {
            #[inline]
            fn clone(&self) -> WishCreatedMetadata {
                WishCreatedMetadata {
                    id: ::core::clone::Clone::clone(&self.id),
                    product_id: ::core::clone::Clone::clone(&self.product_id),
                    product_list_id: ::core::clone::Clone::clone(&self.product_list_id),
                    product_list_position: ::core::clone::Clone::clone(
                        &self.product_list_position,
                    ),
                    product_position: ::core::clone::Clone::clone(
                        &self.product_position,
                    ),
                    source: ::core::clone::Clone::clone(&self.source),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for WishCreatedMetadata {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "WishCreatedMetadata",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "productId",
                        &self.product_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "productListId",
                        &self.product_list_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "productListPosition",
                        &self.product_list_position,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "productPosition",
                        &self.product_position,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "source",
                        &self.source,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for WishCreatedMetadata {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "productId" => _serde::__private::Ok(__Field::__field1),
                                "productListId" => _serde::__private::Ok(__Field::__field2),
                                "productListPosition" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "productPosition" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                "source" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"productId" => _serde::__private::Ok(__Field::__field1),
                                b"productListId" => _serde::__private::Ok(__Field::__field2),
                                b"productListPosition" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"productPosition" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                b"source" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<WishCreatedMetadata>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = WishCreatedMetadata;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct WishCreatedMetadata",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct WishCreatedMetadata with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct WishCreatedMetadata with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct WishCreatedMetadata with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Option<Vec<String>>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct WishCreatedMetadata with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                Option<Vec<String>>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct WishCreatedMetadata with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct WishCreatedMetadata with 6 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(WishCreatedMetadata {
                                id: __field0,
                                product_id: __field1,
                                product_list_id: __field2,
                                product_list_position: __field3,
                                product_position: __field4,
                                source: __field5,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                Option<Vec<String>>,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                Option<Vec<String>>,
                            > = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "productId",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "productListId",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "productListPosition",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<Vec<String>>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "productPosition",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<Vec<String>>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("source"),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("productId")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("productListId")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("productListPosition")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("productPosition")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("source")?
                                }
                            };
                            _serde::__private::Ok(WishCreatedMetadata {
                                id: __field0,
                                product_id: __field1,
                                product_list_id: __field2,
                                product_list_position: __field3,
                                product_position: __field4,
                                source: __field5,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "productId",
                        "productListId",
                        "productListPosition",
                        "productPosition",
                        "source",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "WishCreatedMetadata",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                WishCreatedMetadata,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for WishCreatedMetadata {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for WishCreatedMetadata {
            #[inline]
            fn eq(&self, other: &WishCreatedMetadata) -> bool {
                self.id == other.id && self.product_id == other.product_id
                    && self.product_list_id == other.product_list_id
                    && self.product_list_position == other.product_list_position
                    && self.product_position == other.product_position
                    && self.source == other.source
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for WishCreatedMetadata {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "product_id",
                    "product_list_id",
                    "product_list_position",
                    "product_position",
                    "source",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.product_id,
                    &self.product_list_id,
                    &self.product_list_position,
                    &self.product_position,
                    &&self.source,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "WishCreatedMetadata",
                    names,
                    values,
                )
            }
        }
        impl apache_avro::schema::derive::AvroSchemaComponent for WishCreatedMetadata {
            fn get_schema_in_ctxt(
                named_schemas: &mut std::collections::HashMap<
                    apache_avro::schema::Name,
                    apache_avro::schema::Schema,
                >,
                enclosing_namespace: &Option<String>,
            ) -> apache_avro::schema::Schema {
                let name = apache_avro::schema::Name::new("WishCreatedMetadata")
                    .expect(
                        &{
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Unable to parse schema name {0}",
                                    "WishCreatedMetadata",
                                ),
                            );
                            res
                        }[..],
                    )
                    .fully_qualified_name(enclosing_namespace);
                let enclosing_namespace = &name.namespace;
                if named_schemas.contains_key(&name) {
                    apache_avro::schema::Schema::Ref {
                        name: name.clone(),
                    }
                } else {
                    named_schemas
                        .insert(
                            name.clone(),
                            apache_avro::schema::Schema::Ref {
                                name: name.clone(),
                            },
                        );
                    let schema_fields = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            apache_avro::schema::RecordField {
                                name: "id".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 0usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "productId".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    String,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 1usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "productListId".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    String,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 2usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "productListPosition".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    Vec<String>,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 3usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "productPosition".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    Vec<String>,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 4usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "source".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    String,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 5usize,
                                custom_attributes: Default::default(),
                            },
                        ]),
                    );
                    let name = apache_avro::schema::Name::new("WishCreatedMetadata")
                        .expect(
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unable to parse struct name for schema {0}",
                                        "WishCreatedMetadata",
                                    ),
                                );
                                res
                            }[..],
                        );
                    let lookup: std::collections::BTreeMap<String, usize> = schema_fields
                        .iter()
                        .map(|field| (field.name.to_owned(), field.position))
                        .collect();
                    apache_avro::schema::Schema::Record(apache_avro::schema::RecordSchema {
                        name,
                        aliases: None,
                        doc: None,
                        fields: schema_fields,
                        lookup,
                        attributes: Default::default(),
                    })
                }
            }
        }
        impl apache_avro::schema::derive::AvroSchemaComponent for Photos {
            fn get_schema_in_ctxt(
                named_schemas: &mut std::collections::HashMap<
                    apache_avro::schema::Name,
                    apache_avro::Schema,
                >,
                enclosing_namespace: &apache_avro::schema::Namespace,
            ) -> apache_avro::Schema {
                apache_avro::Schema::parse_str(
                        "[\"string\",{\"type\":\"array\",\"items\":\"string\"}]",
                    )
                    .unwrap()
            }
        }
        pub enum Photos {
            String(String),
            Array(Vec<String>),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Photos {
            #[inline]
            fn clone(&self) -> Photos {
                match self {
                    Photos::String(__self_0) => {
                        Photos::String(::core::clone::Clone::clone(__self_0))
                    }
                    Photos::Array(__self_0) => {
                        Photos::Array(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Photos {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        Photos::String(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "Photos",
                                0u32,
                                "String",
                                __field0,
                            )
                        }
                        Photos::Array(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "Photos",
                                1u32,
                                "Array",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Photos {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "String" => _serde::__private::Ok(__Field::__field0),
                                "Array" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"String" => _serde::__private::Ok(__Field::__field0),
                                b"Array" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Photos>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Photos;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum Photos",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            String,
                                        >(__variant),
                                        Photos::String,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Vec<String>,
                                        >(__variant),
                                        Photos::Array,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["String", "Array"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "Photos",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Photos>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Photos {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Photos {
            #[inline]
            fn eq(&self, other: &Photos) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (Photos::String(__self_0), Photos::String(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Photos::Array(__self_0), Photos::Array(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Photos {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Photos::String(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "String",
                            &__self_0,
                        )
                    }
                    Photos::Array(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Array",
                            &__self_0,
                        )
                    }
                }
            }
        }
        pub struct WishCreatedProductRef {
            #[avro(rename = "countryCode")]
            #[serde(rename = "countryCode")]
            pub country_code: String,
            #[avro(rename = "createdAt")]
            #[serde(rename = "createdAt")]
            pub created_at: String,
            #[avro(rename = "currency")]
            #[serde(rename = "currency")]
            pub currency: Option<String>,
            #[avro(rename = "domainName")]
            #[serde(rename = "domainName")]
            pub domain_name: String,
            #[avro(rename = "id")]
            #[serde(rename = "id")]
            pub id: String,
            #[avro(rename = "originalUrl")]
            #[serde(rename = "originalUrl")]
            pub original_url: String,
            #[avro(rename = "price")]
            #[serde(rename = "price")]
            pub price: Option<f64>,
            #[avro(rename = "priceRefThirtyDays")]
            #[serde(rename = "priceRefThirtyDays")]
            pub price_ref_thirty_days: Option<f64>,
            #[avro(rename = "priceRefThirtyDaysAt")]
            #[serde(rename = "priceRefThirtyDaysAt")]
            pub price_ref_thirty_days_at: Option<String>,
            #[avro(rename = "source")]
            #[serde(rename = "source")]
            pub source: Option<String>,
            #[avro(rename = "updatedAt")]
            #[serde(rename = "updatedAt")]
            pub updated_at: String,
            #[avro(rename = "uurl")]
            #[serde(rename = "uurl")]
            pub uurl: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for WishCreatedProductRef {
            #[inline]
            fn clone(&self) -> WishCreatedProductRef {
                WishCreatedProductRef {
                    country_code: ::core::clone::Clone::clone(&self.country_code),
                    created_at: ::core::clone::Clone::clone(&self.created_at),
                    currency: ::core::clone::Clone::clone(&self.currency),
                    domain_name: ::core::clone::Clone::clone(&self.domain_name),
                    id: ::core::clone::Clone::clone(&self.id),
                    original_url: ::core::clone::Clone::clone(&self.original_url),
                    price: ::core::clone::Clone::clone(&self.price),
                    price_ref_thirty_days: ::core::clone::Clone::clone(
                        &self.price_ref_thirty_days,
                    ),
                    price_ref_thirty_days_at: ::core::clone::Clone::clone(
                        &self.price_ref_thirty_days_at,
                    ),
                    source: ::core::clone::Clone::clone(&self.source),
                    updated_at: ::core::clone::Clone::clone(&self.updated_at),
                    uurl: ::core::clone::Clone::clone(&self.uurl),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for WishCreatedProductRef {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "WishCreatedProductRef",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "countryCode",
                        &self.country_code,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "createdAt",
                        &self.created_at,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "currency",
                        &self.currency,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "domainName",
                        &self.domain_name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "originalUrl",
                        &self.original_url,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "price",
                        &self.price,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "priceRefThirtyDays",
                        &self.price_ref_thirty_days,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "priceRefThirtyDaysAt",
                        &self.price_ref_thirty_days_at,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "source",
                        &self.source,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "updatedAt",
                        &self.updated_at,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "uurl",
                        &self.uurl,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for WishCreatedProductRef {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "countryCode" => _serde::__private::Ok(__Field::__field0),
                                "createdAt" => _serde::__private::Ok(__Field::__field1),
                                "currency" => _serde::__private::Ok(__Field::__field2),
                                "domainName" => _serde::__private::Ok(__Field::__field3),
                                "id" => _serde::__private::Ok(__Field::__field4),
                                "originalUrl" => _serde::__private::Ok(__Field::__field5),
                                "price" => _serde::__private::Ok(__Field::__field6),
                                "priceRefThirtyDays" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                "priceRefThirtyDaysAt" => {
                                    _serde::__private::Ok(__Field::__field8)
                                }
                                "source" => _serde::__private::Ok(__Field::__field9),
                                "updatedAt" => _serde::__private::Ok(__Field::__field10),
                                "uurl" => _serde::__private::Ok(__Field::__field11),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"countryCode" => _serde::__private::Ok(__Field::__field0),
                                b"createdAt" => _serde::__private::Ok(__Field::__field1),
                                b"currency" => _serde::__private::Ok(__Field::__field2),
                                b"domainName" => _serde::__private::Ok(__Field::__field3),
                                b"id" => _serde::__private::Ok(__Field::__field4),
                                b"originalUrl" => _serde::__private::Ok(__Field::__field5),
                                b"price" => _serde::__private::Ok(__Field::__field6),
                                b"priceRefThirtyDays" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                b"priceRefThirtyDaysAt" => {
                                    _serde::__private::Ok(__Field::__field8)
                                }
                                b"source" => _serde::__private::Ok(__Field::__field9),
                                b"updatedAt" => _serde::__private::Ok(__Field::__field10),
                                b"uurl" => _serde::__private::Ok(__Field::__field11),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<WishCreatedProductRef>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = WishCreatedProductRef;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct WishCreatedProductRef",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct WishCreatedProductRef with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct WishCreatedProductRef with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct WishCreatedProductRef with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct WishCreatedProductRef with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct WishCreatedProductRef with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct WishCreatedProductRef with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                Option<f64>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct WishCreatedProductRef with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match _serde::de::SeqAccess::next_element::<
                                Option<f64>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct WishCreatedProductRef with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct WishCreatedProductRef with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field9 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct WishCreatedProductRef with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field10 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            10usize,
                                            &"struct WishCreatedProductRef with 12 elements",
                                        ),
                                    );
                                }
                            };
                            let __field11 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            11usize,
                                            &"struct WishCreatedProductRef with 12 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(WishCreatedProductRef {
                                country_code: __field0,
                                created_at: __field1,
                                currency: __field2,
                                domain_name: __field3,
                                id: __field4,
                                original_url: __field5,
                                price: __field6,
                                price_ref_thirty_days: __field7,
                                price_ref_thirty_days_at: __field8,
                                source: __field9,
                                updated_at: __field10,
                                uurl: __field11,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<Option<f64>> = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<Option<f64>> = _serde::__private::None;
                            let mut __field8: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field9: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field10: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field11: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "countryCode",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "createdAt",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "currency",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "domainName",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "originalUrl",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("price"),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<f64>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "priceRefThirtyDays",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<f64>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "priceRefThirtyDaysAt",
                                                ),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field9 => {
                                        if _serde::__private::Option::is_some(&__field9) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("source"),
                                            );
                                        }
                                        __field9 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field10 => {
                                        if _serde::__private::Option::is_some(&__field10) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "updatedAt",
                                                ),
                                            );
                                        }
                                        __field10 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field11 => {
                                        if _serde::__private::Option::is_some(&__field11) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("uurl"),
                                            );
                                        }
                                        __field11 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("countryCode")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("createdAt")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("currency")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("domainName")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("originalUrl")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("price")?
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("priceRefThirtyDays")?
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "priceRefThirtyDaysAt",
                                    )?
                                }
                            };
                            let __field9 = match __field9 {
                                _serde::__private::Some(__field9) => __field9,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("source")?
                                }
                            };
                            let __field10 = match __field10 {
                                _serde::__private::Some(__field10) => __field10,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("updatedAt")?
                                }
                            };
                            let __field11 = match __field11 {
                                _serde::__private::Some(__field11) => __field11,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("uurl")?
                                }
                            };
                            _serde::__private::Ok(WishCreatedProductRef {
                                country_code: __field0,
                                created_at: __field1,
                                currency: __field2,
                                domain_name: __field3,
                                id: __field4,
                                original_url: __field5,
                                price: __field6,
                                price_ref_thirty_days: __field7,
                                price_ref_thirty_days_at: __field8,
                                source: __field9,
                                updated_at: __field10,
                                uurl: __field11,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "countryCode",
                        "createdAt",
                        "currency",
                        "domainName",
                        "id",
                        "originalUrl",
                        "price",
                        "priceRefThirtyDays",
                        "priceRefThirtyDaysAt",
                        "source",
                        "updatedAt",
                        "uurl",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "WishCreatedProductRef",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                WishCreatedProductRef,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for WishCreatedProductRef {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for WishCreatedProductRef {
            #[inline]
            fn eq(&self, other: &WishCreatedProductRef) -> bool {
                self.country_code == other.country_code
                    && self.created_at == other.created_at
                    && self.currency == other.currency
                    && self.domain_name == other.domain_name && self.id == other.id
                    && self.original_url == other.original_url
                    && self.price == other.price
                    && self.price_ref_thirty_days == other.price_ref_thirty_days
                    && self.price_ref_thirty_days_at == other.price_ref_thirty_days_at
                    && self.source == other.source && self.updated_at == other.updated_at
                    && self.uurl == other.uurl
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for WishCreatedProductRef {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "country_code",
                    "created_at",
                    "currency",
                    "domain_name",
                    "id",
                    "original_url",
                    "price",
                    "price_ref_thirty_days",
                    "price_ref_thirty_days_at",
                    "source",
                    "updated_at",
                    "uurl",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.country_code,
                    &self.created_at,
                    &self.currency,
                    &self.domain_name,
                    &self.id,
                    &self.original_url,
                    &self.price,
                    &self.price_ref_thirty_days,
                    &self.price_ref_thirty_days_at,
                    &self.source,
                    &self.updated_at,
                    &&self.uurl,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "WishCreatedProductRef",
                    names,
                    values,
                )
            }
        }
        impl apache_avro::schema::derive::AvroSchemaComponent for WishCreatedProductRef {
            fn get_schema_in_ctxt(
                named_schemas: &mut std::collections::HashMap<
                    apache_avro::schema::Name,
                    apache_avro::schema::Schema,
                >,
                enclosing_namespace: &Option<String>,
            ) -> apache_avro::schema::Schema {
                let name = apache_avro::schema::Name::new("WishCreatedProductRef")
                    .expect(
                        &{
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Unable to parse schema name {0}",
                                    "WishCreatedProductRef",
                                ),
                            );
                            res
                        }[..],
                    )
                    .fully_qualified_name(enclosing_namespace);
                let enclosing_namespace = &name.namespace;
                if named_schemas.contains_key(&name) {
                    apache_avro::schema::Schema::Ref {
                        name: name.clone(),
                    }
                } else {
                    named_schemas
                        .insert(
                            name.clone(),
                            apache_avro::schema::Schema::Ref {
                                name: name.clone(),
                            },
                        );
                    let schema_fields = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            apache_avro::schema::RecordField {
                                name: "countryCode".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 0usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "createdAt".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 1usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "currency".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    String,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 2usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "domainName".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 3usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "id".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 4usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "originalUrl".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 5usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "price".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    f64,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 6usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "priceRefThirtyDays".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    f64,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 7usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "priceRefThirtyDaysAt".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    String,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 8usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "source".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    String,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 9usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "updatedAt".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 10usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "uurl".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 11usize,
                                custom_attributes: Default::default(),
                            },
                        ]),
                    );
                    let name = apache_avro::schema::Name::new("WishCreatedProductRef")
                        .expect(
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unable to parse struct name for schema {0}",
                                        "WishCreatedProductRef",
                                    ),
                                );
                                res
                            }[..],
                        );
                    let lookup: std::collections::BTreeMap<String, usize> = schema_fields
                        .iter()
                        .map(|field| (field.name.to_owned(), field.position))
                        .collect();
                    apache_avro::schema::Schema::Record(apache_avro::schema::RecordSchema {
                        name,
                        aliases: None,
                        doc: None,
                        fields: schema_fields,
                        lookup,
                        attributes: Default::default(),
                    })
                }
            }
        }
        pub struct WishCreated {
            #[avro(rename = "createdAt")]
            #[serde(rename = "createdAt")]
            pub created_at: String,
            #[avro(rename = "currency")]
            #[serde(rename = "currency")]
            pub currency: String,
            #[avro(rename = "description")]
            #[serde(rename = "description")]
            pub description: Option<String>,
            #[avro(rename = "id")]
            #[serde(rename = "id")]
            pub id: String,
            #[avro(rename = "index")]
            #[serde(rename = "index")]
            pub index: f64,
            #[avro(rename = "metadata")]
            #[serde(rename = "metadata")]
            pub metadata: Option<WishCreatedMetadata>,
            #[avro(rename = "photos")]
            #[serde(rename = "photos")]
            pub photos: Photos,
            #[avro(rename = "price")]
            #[serde(rename = "price")]
            pub price: f64,
            #[avro(rename = "productRef")]
            #[serde(rename = "productRef")]
            pub product_ref: Option<WishCreatedProductRef>,
            #[avro(rename = "quantity")]
            #[serde(rename = "quantity")]
            pub quantity: f64,
            #[avro(rename = "title")]
            #[serde(rename = "title")]
            pub title: String,
            #[avro(rename = "url")]
            #[serde(rename = "url")]
            pub url: Option<String>,
            #[avro(rename = "userId")]
            #[serde(rename = "userId")]
            pub user_id: String,
            #[avro(rename = "wishlistId")]
            #[serde(rename = "wishlistId")]
            pub wishlist_id: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for WishCreated {
            #[inline]
            fn clone(&self) -> WishCreated {
                WishCreated {
                    created_at: ::core::clone::Clone::clone(&self.created_at),
                    currency: ::core::clone::Clone::clone(&self.currency),
                    description: ::core::clone::Clone::clone(&self.description),
                    id: ::core::clone::Clone::clone(&self.id),
                    index: ::core::clone::Clone::clone(&self.index),
                    metadata: ::core::clone::Clone::clone(&self.metadata),
                    photos: ::core::clone::Clone::clone(&self.photos),
                    price: ::core::clone::Clone::clone(&self.price),
                    product_ref: ::core::clone::Clone::clone(&self.product_ref),
                    quantity: ::core::clone::Clone::clone(&self.quantity),
                    title: ::core::clone::Clone::clone(&self.title),
                    url: ::core::clone::Clone::clone(&self.url),
                    user_id: ::core::clone::Clone::clone(&self.user_id),
                    wishlist_id: ::core::clone::Clone::clone(&self.wishlist_id),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for WishCreated {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "WishCreated",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                            + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "createdAt",
                        &self.created_at,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "currency",
                        &self.currency,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description",
                        &self.description,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "index",
                        &self.index,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "metadata",
                        &self.metadata,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "photos",
                        &self.photos,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "price",
                        &self.price,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "productRef",
                        &self.product_ref,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "quantity",
                        &self.quantity,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "title",
                        &self.title,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "url",
                        &self.url,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "userId",
                        &self.user_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "wishlistId",
                        &self.wishlist_id,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for WishCreated {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __field12,
                        __field13,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                12u64 => _serde::__private::Ok(__Field::__field12),
                                13u64 => _serde::__private::Ok(__Field::__field13),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "createdAt" => _serde::__private::Ok(__Field::__field0),
                                "currency" => _serde::__private::Ok(__Field::__field1),
                                "description" => _serde::__private::Ok(__Field::__field2),
                                "id" => _serde::__private::Ok(__Field::__field3),
                                "index" => _serde::__private::Ok(__Field::__field4),
                                "metadata" => _serde::__private::Ok(__Field::__field5),
                                "photos" => _serde::__private::Ok(__Field::__field6),
                                "price" => _serde::__private::Ok(__Field::__field7),
                                "productRef" => _serde::__private::Ok(__Field::__field8),
                                "quantity" => _serde::__private::Ok(__Field::__field9),
                                "title" => _serde::__private::Ok(__Field::__field10),
                                "url" => _serde::__private::Ok(__Field::__field11),
                                "userId" => _serde::__private::Ok(__Field::__field12),
                                "wishlistId" => _serde::__private::Ok(__Field::__field13),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"createdAt" => _serde::__private::Ok(__Field::__field0),
                                b"currency" => _serde::__private::Ok(__Field::__field1),
                                b"description" => _serde::__private::Ok(__Field::__field2),
                                b"id" => _serde::__private::Ok(__Field::__field3),
                                b"index" => _serde::__private::Ok(__Field::__field4),
                                b"metadata" => _serde::__private::Ok(__Field::__field5),
                                b"photos" => _serde::__private::Ok(__Field::__field6),
                                b"price" => _serde::__private::Ok(__Field::__field7),
                                b"productRef" => _serde::__private::Ok(__Field::__field8),
                                b"quantity" => _serde::__private::Ok(__Field::__field9),
                                b"title" => _serde::__private::Ok(__Field::__field10),
                                b"url" => _serde::__private::Ok(__Field::__field11),
                                b"userId" => _serde::__private::Ok(__Field::__field12),
                                b"wishlistId" => _serde::__private::Ok(__Field::__field13),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<WishCreated>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = WishCreated;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct WishCreated",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                f64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                Option<WishCreatedMetadata>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                Photos,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match _serde::de::SeqAccess::next_element::<
                                f64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match _serde::de::SeqAccess::next_element::<
                                Option<WishCreatedProductRef>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field9 = match _serde::de::SeqAccess::next_element::<
                                f64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field10 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            10usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field11 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            11usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field12 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            12usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field13 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            13usize,
                                            &"struct WishCreated with 14 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(WishCreated {
                                created_at: __field0,
                                currency: __field1,
                                description: __field2,
                                id: __field3,
                                index: __field4,
                                metadata: __field5,
                                photos: __field6,
                                price: __field7,
                                product_ref: __field8,
                                quantity: __field9,
                                title: __field10,
                                url: __field11,
                                user_id: __field12,
                                wishlist_id: __field13,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<f64> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<
                                Option<WishCreatedMetadata>,
                            > = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<Photos> = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<f64> = _serde::__private::None;
                            let mut __field8: _serde::__private::Option<
                                Option<WishCreatedProductRef>,
                            > = _serde::__private::None;
                            let mut __field9: _serde::__private::Option<f64> = _serde::__private::None;
                            let mut __field10: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field11: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field12: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field13: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "createdAt",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "currency",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "description",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("index"),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "metadata",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<WishCreatedMetadata>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("photos"),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Photos>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("price"),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "productRef",
                                                ),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<WishCreatedProductRef>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field9 => {
                                        if _serde::__private::Option::is_some(&__field9) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "quantity",
                                                ),
                                            );
                                        }
                                        __field9 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<f64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field10 => {
                                        if _serde::__private::Option::is_some(&__field10) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("title"),
                                            );
                                        }
                                        __field10 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field11 => {
                                        if _serde::__private::Option::is_some(&__field11) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("url"),
                                            );
                                        }
                                        __field11 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field12 => {
                                        if _serde::__private::Option::is_some(&__field12) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("userId"),
                                            );
                                        }
                                        __field12 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field13 => {
                                        if _serde::__private::Option::is_some(&__field13) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "wishlistId",
                                                ),
                                            );
                                        }
                                        __field13 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("createdAt")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("currency")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("description")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("index")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("metadata")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("photos")?
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("price")?
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("productRef")?
                                }
                            };
                            let __field9 = match __field9 {
                                _serde::__private::Some(__field9) => __field9,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("quantity")?
                                }
                            };
                            let __field10 = match __field10 {
                                _serde::__private::Some(__field10) => __field10,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("title")?
                                }
                            };
                            let __field11 = match __field11 {
                                _serde::__private::Some(__field11) => __field11,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("url")?
                                }
                            };
                            let __field12 = match __field12 {
                                _serde::__private::Some(__field12) => __field12,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("userId")?
                                }
                            };
                            let __field13 = match __field13 {
                                _serde::__private::Some(__field13) => __field13,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("wishlistId")?
                                }
                            };
                            _serde::__private::Ok(WishCreated {
                                created_at: __field0,
                                currency: __field1,
                                description: __field2,
                                id: __field3,
                                index: __field4,
                                metadata: __field5,
                                photos: __field6,
                                price: __field7,
                                product_ref: __field8,
                                quantity: __field9,
                                title: __field10,
                                url: __field11,
                                user_id: __field12,
                                wishlist_id: __field13,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "createdAt",
                        "currency",
                        "description",
                        "id",
                        "index",
                        "metadata",
                        "photos",
                        "price",
                        "productRef",
                        "quantity",
                        "title",
                        "url",
                        "userId",
                        "wishlistId",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "WishCreated",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<WishCreated>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for WishCreated {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for WishCreated {
            #[inline]
            fn eq(&self, other: &WishCreated) -> bool {
                self.created_at == other.created_at && self.currency == other.currency
                    && self.description == other.description && self.id == other.id
                    && self.index == other.index && self.metadata == other.metadata
                    && self.photos == other.photos && self.price == other.price
                    && self.product_ref == other.product_ref
                    && self.quantity == other.quantity && self.title == other.title
                    && self.url == other.url && self.user_id == other.user_id
                    && self.wishlist_id == other.wishlist_id
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for WishCreated {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "created_at",
                    "currency",
                    "description",
                    "id",
                    "index",
                    "metadata",
                    "photos",
                    "price",
                    "product_ref",
                    "quantity",
                    "title",
                    "url",
                    "user_id",
                    "wishlist_id",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.created_at,
                    &self.currency,
                    &self.description,
                    &self.id,
                    &self.index,
                    &self.metadata,
                    &self.photos,
                    &self.price,
                    &self.product_ref,
                    &self.quantity,
                    &self.title,
                    &self.url,
                    &self.user_id,
                    &&self.wishlist_id,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "WishCreated",
                    names,
                    values,
                )
            }
        }
        impl apache_avro::schema::derive::AvroSchemaComponent for WishCreated {
            fn get_schema_in_ctxt(
                named_schemas: &mut std::collections::HashMap<
                    apache_avro::schema::Name,
                    apache_avro::schema::Schema,
                >,
                enclosing_namespace: &Option<String>,
            ) -> apache_avro::schema::Schema {
                let name = apache_avro::schema::Name::new("WishCreated")
                    .expect(
                        &{
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Unable to parse schema name {0}",
                                    "WishCreated",
                                ),
                            );
                            res
                        }[..],
                    )
                    .fully_qualified_name(enclosing_namespace);
                let enclosing_namespace = &name.namespace;
                if named_schemas.contains_key(&name) {
                    apache_avro::schema::Schema::Ref {
                        name: name.clone(),
                    }
                } else {
                    named_schemas
                        .insert(
                            name.clone(),
                            apache_avro::schema::Schema::Ref {
                                name: name.clone(),
                            },
                        );
                    let schema_fields = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            apache_avro::schema::RecordField {
                                name: "createdAt".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 0usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "currency".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 1usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "description".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    String,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 2usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "id".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 3usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "index".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::Double,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 4usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "metadata".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    WishCreatedMetadata,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 5usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "photos".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Photos as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 6usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "price".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::Double,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 7usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "productRef".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    WishCreatedProductRef,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 8usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "quantity".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::Double,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 9usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "title".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 10usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "url".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: <Option<
                                    String,
                                > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                                    named_schemas,
                                    enclosing_namespace,
                                ),
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 11usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "userId".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 12usize,
                                custom_attributes: Default::default(),
                            },
                            apache_avro::schema::RecordField {
                                name: "wishlistId".to_string(),
                                doc: None,
                                default: None,
                                aliases: None,
                                schema: apache_avro::schema::Schema::String,
                                order: apache_avro::schema::RecordFieldOrder::Ascending,
                                position: 13usize,
                                custom_attributes: Default::default(),
                            },
                        ]),
                    );
                    let name = apache_avro::schema::Name::new("WishCreated")
                        .expect(
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unable to parse struct name for schema {0}",
                                        "WishCreated",
                                    ),
                                );
                                res
                            }[..],
                        );
                    let lookup: std::collections::BTreeMap<String, usize> = schema_fields
                        .iter()
                        .map(|field| (field.name.to_owned(), field.position))
                        .collect();
                    apache_avro::schema::Schema::Record(apache_avro::schema::RecordSchema {
                        name,
                        aliases: None,
                        doc: None,
                        fields: schema_fields,
                        lookup,
                        attributes: Default::default(),
                    })
                }
            }
        }
    }
    pub use test::WishCreated;
}
enum Foo {
    String(String),
    Int(i8),
    Array(Vec<String>),
}
impl Foo {
    fn foo() {
        {
            ::std::io::_print(format_args!("FOOBAR\n"));
        }
    }
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Foo {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                Foo::String(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Foo",
                        0u32,
                        "String",
                        __field0,
                    )
                }
                Foo::Int(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Foo",
                        1u32,
                        "Int",
                        __field0,
                    )
                }
                Foo::Array(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Foo",
                        2u32,
                        "Array",
                        __field0,
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Foo {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 3",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "String" => _serde::__private::Ok(__Field::__field0),
                        "Int" => _serde::__private::Ok(__Field::__field1),
                        "Array" => _serde::__private::Ok(__Field::__field2),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"String" => _serde::__private::Ok(__Field::__field0),
                        b"Int" => _serde::__private::Ok(__Field::__field1),
                        b"Array" => _serde::__private::Ok(__Field::__field2),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Foo>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Foo;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "enum Foo")
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                Foo::String,
                            )
                        }
                        (__Field::__field1, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<i8>(__variant),
                                Foo::Int,
                            )
                        }
                        (__Field::__field2, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Vec<String>,
                                >(__variant),
                                Foo::Array,
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &["String", "Int", "Array"];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "Foo",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<Foo>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::fmt::Debug for Foo {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            Foo::String(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "String", &__self_0)
            }
            Foo::Int(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Int", &__self_0)
            }
            Foo::Array(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Array", &__self_0)
            }
        }
    }
}
impl apache_avro::schema::derive::AvroSchemaComponent for Foo {
    fn get_schema_in_ctxt(
        named_schemas: &mut std::collections::HashMap<
            apache_avro::schema::Name,
            apache_avro::Schema,
        >,
        enclosing_namespace: &apache_avro::schema::Namespace,
    ) -> apache_avro::Schema {
        apache_avro::schema::Schema::parse_str(
                r#"
      [
            "string",
            "int",
            {
                "type": "array",
                "items": "string"
            }
        ]
    
      "#,
            )
            .unwrap()
    }
}
struct Test1 {
    age: u8,
    hmm: Foo,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Test1 {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "Test1",
                false as usize + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "age",
                &self.age,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "hmm",
                &self.hmm,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Test1 {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "age" => _serde::__private::Ok(__Field::__field0),
                        "hmm" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"age" => _serde::__private::Ok(__Field::__field0),
                        b"hmm" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Test1>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Test1;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "struct Test1")
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        u8,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Test1 with 2 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        Foo,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Test1 with 2 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(Test1 {
                        age: __field0,
                        hmm: __field1,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<u8> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<Foo> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("age"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("hmm"),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<Foo>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("age")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("hmm")?
                        }
                    };
                    _serde::__private::Ok(Test1 {
                        age: __field0,
                        hmm: __field1,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["age", "hmm"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "Test1",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<Test1>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::fmt::Debug for Test1 {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "Test1",
            "age",
            &self.age,
            "hmm",
            &&self.hmm,
        )
    }
}
impl apache_avro::schema::derive::AvroSchemaComponent for Test1 {
    fn get_schema_in_ctxt(
        named_schemas: &mut std::collections::HashMap<
            apache_avro::schema::Name,
            apache_avro::schema::Schema,
        >,
        enclosing_namespace: &Option<String>,
    ) -> apache_avro::schema::Schema {
        let name = apache_avro::schema::Name::new("Test1")
            .expect(
                &{
                    let res = ::alloc::fmt::format(
                        format_args!("Unable to parse schema name {0}", "Test1"),
                    );
                    res
                }[..],
            )
            .fully_qualified_name(enclosing_namespace);
        let enclosing_namespace = &name.namespace;
        if named_schemas.contains_key(&name) {
            apache_avro::schema::Schema::Ref {
                name: name.clone(),
            }
        } else {
            named_schemas
                .insert(
                    name.clone(),
                    apache_avro::schema::Schema::Ref {
                        name: name.clone(),
                    },
                );
            let schema_fields = <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    apache_avro::schema::RecordField {
                        name: "age".to_string(),
                        doc: None,
                        default: None,
                        aliases: None,
                        schema: apache_avro::schema::Schema::Int,
                        order: apache_avro::schema::RecordFieldOrder::Ascending,
                        position: 0usize,
                        custom_attributes: Default::default(),
                    },
                    apache_avro::schema::RecordField {
                        name: "hmm".to_string(),
                        doc: None,
                        default: None,
                        aliases: None,
                        schema: <Foo as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                            named_schemas,
                            enclosing_namespace,
                        ),
                        order: apache_avro::schema::RecordFieldOrder::Ascending,
                        position: 1usize,
                        custom_attributes: Default::default(),
                    },
                ]),
            );
            let name = apache_avro::schema::Name::new("Test1")
                .expect(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Unable to parse struct name for schema {0}",
                                "Test1",
                            ),
                        );
                        res
                    }[..],
                );
            let lookup: std::collections::BTreeMap<String, usize> = schema_fields
                .iter()
                .map(|field| (field.name.to_owned(), field.position))
                .collect();
            apache_avro::schema::Schema::Record(apache_avro::schema::RecordSchema {
                name,
                aliases: None,
                doc: None,
                fields: schema_fields,
                lookup,
                attributes: Default::default(),
            })
        }
    }
}
struct Test2 {
    lines: Vec<String>,
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Test2 {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "Test2",
                false as usize + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "lines",
                &self.lines,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
impl apache_avro::schema::derive::AvroSchemaComponent for Test2 {
    fn get_schema_in_ctxt(
        named_schemas: &mut std::collections::HashMap<
            apache_avro::schema::Name,
            apache_avro::schema::Schema,
        >,
        enclosing_namespace: &Option<String>,
    ) -> apache_avro::schema::Schema {
        let name = apache_avro::schema::Name::new("Test2")
            .expect(
                &{
                    let res = ::alloc::fmt::format(
                        format_args!("Unable to parse schema name {0}", "Test2"),
                    );
                    res
                }[..],
            )
            .fully_qualified_name(enclosing_namespace);
        let enclosing_namespace = &name.namespace;
        if named_schemas.contains_key(&name) {
            apache_avro::schema::Schema::Ref {
                name: name.clone(),
            }
        } else {
            named_schemas
                .insert(
                    name.clone(),
                    apache_avro::schema::Schema::Ref {
                        name: name.clone(),
                    },
                );
            let schema_fields = <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    apache_avro::schema::RecordField {
                        name: "lines".to_string(),
                        doc: None,
                        default: None,
                        aliases: None,
                        schema: <Vec<
                            String,
                        > as apache_avro::schema::derive::AvroSchemaComponent>::get_schema_in_ctxt(
                            named_schemas,
                            enclosing_namespace,
                        ),
                        order: apache_avro::schema::RecordFieldOrder::Ascending,
                        position: 0usize,
                        custom_attributes: Default::default(),
                    },
                ]),
            );
            let name = apache_avro::schema::Name::new("Test2")
                .expect(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Unable to parse struct name for schema {0}",
                                "Test2",
                            ),
                        );
                        res
                    }[..],
                );
            let lookup: std::collections::BTreeMap<String, usize> = schema_fields
                .iter()
                .map(|field| (field.name.to_owned(), field.position))
                .collect();
            apache_avro::schema::Schema::Record(apache_avro::schema::RecordSchema {
                name,
                aliases: None,
                doc: None,
                fields: schema_fields,
                lookup,
                attributes: Default::default(),
            })
        }
    }
}
enum EnumTest1 {
    string(String),
    int(i8),
    array(Vec<u8>),
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for EnumTest1 {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                EnumTest1::string(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "EnumTest1",
                        0u32,
                        "string",
                        __field0,
                    )
                }
                EnumTest1::int(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "EnumTest1",
                        1u32,
                        "int",
                        __field0,
                    )
                }
                EnumTest1::array(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "EnumTest1",
                        2u32,
                        "array",
                        __field0,
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for EnumTest1 {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 3",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "string" => _serde::__private::Ok(__Field::__field0),
                        "int" => _serde::__private::Ok(__Field::__field1),
                        "array" => _serde::__private::Ok(__Field::__field2),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"string" => _serde::__private::Ok(__Field::__field0),
                        b"int" => _serde::__private::Ok(__Field::__field1),
                        b"array" => _serde::__private::Ok(__Field::__field2),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<EnumTest1>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = EnumTest1;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "enum EnumTest1",
                    )
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                EnumTest1::string,
                            )
                        }
                        (__Field::__field1, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<i8>(__variant),
                                EnumTest1::int,
                            )
                        }
                        (__Field::__field2, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Vec<u8>,
                                >(__variant),
                                EnumTest1::array,
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &["string", "int", "array"];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "EnumTest1",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<EnumTest1>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::fmt::Debug for EnumTest1 {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            EnumTest1::string(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "string", &__self_0)
            }
            EnumTest1::int(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "int", &__self_0)
            }
            EnumTest1::array(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "array", &__self_0)
            }
        }
    }
}
fn main1() {
    let schema = apache_avro::schema::Schema::parse_str(
            r#"["string","int", {"type": "array", "items": "int"}]"#,
        )
        .unwrap();
    {
        ::std::io::_print(format_args!("{0:?}\n", schema));
    };
    let a = apache_avro::types::Value::Union(
        1,
        Box::new(apache_avro::types::Value::Int(1)),
    );
    let a = apache_avro::types::Value::Union(
        0,
        Box::new(apache_avro::types::Value::String("Hello World!".into())),
    );
    let a = apache_avro::types::Value::Union(
        2,
        Box::new(
            apache_avro::types::Value::Array(
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([apache_avro::types::Value::Int(13)]),
                ),
            ),
        ),
    );
    let a = apache_avro::to_value(
            EnumTest1::array(
                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([12])),
            ),
        )
        .unwrap();
    {
        ::std::io::_print(format_args!("{0:?}\n", &a));
    };
    let mut b = apache_avro::to_avro_datum(&schema, a).unwrap();
    let a = apache_avro::from_avro_datum(&schema, &mut b.as_slice(), None).unwrap();
    let b = apache_avro::from_value::<EnumTest1>(&a).unwrap();
    {
        ::std::io::_print(format_args!("{0:?}\n", &a));
    };
    return;
    let schema = Test1::get_schema();
    {
        ::std::io::_print(format_args!("Schema\n{0}\n", schema.canonical_form()));
    };
    let obj = Test1 {
        age: 1,
        hmm: Foo::Array(
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new(["TEST".to_string()])),
        ),
    };
    {
        ::std::io::_print(format_args!("obj: {0:?}\n", obj));
    };
    let obj_json = serde_json::to_string(&obj).unwrap();
    {
        ::std::io::_print(format_args!("obj_json: {0:?}\n", obj_json));
    };
    let obj = serde_json::from_str::<Test1>(&obj_json).unwrap();
    {
        ::std::io::_print(format_args!("obj: {0:?}\n", obj));
    };
    let avro_value = apache_avro::to_value(obj).unwrap();
    {
        ::std::io::_print(format_args!("avro_value: {0:?}\n", avro_value));
    };
    let obj_avro = apache_avro::to_avro_datum(&schema, avro_value).unwrap();
    {
        ::std::io::_print(format_args!("obj_avro: {0:?}\n", obj_avro));
    };
    let obj_value = apache_avro::from_avro_datum(&schema, &mut obj_avro.as_slice(), None)
        .unwrap();
    {
        ::std::io::_print(format_args!("obj_value: {0:?}\n", obj_value));
    };
    let obj = apache_avro::from_value::<Test1>(&obj_value).unwrap();
    {
        ::std::io::_print(format_args!("obj: {0:?}\n", obj));
    };
}
fn main() {
    let json = r#"
    {
        "title": "Få Street food derhjemme af Katrine Klinken som Hæftet bog på dansk - 9788740058437",
        "currency": "DKK",
        "description": null,
        "index": -14,
        "price": 0,
        "photos": [
            "https://s.onskeskyen.dk/uploads/images/wish/c2/f9/7a/f4/9b/ba/c2f97af49bba.jpeg"
        ],
        "id": "v4et1tBnoqLOfDbA",
        "userId": "wV7RDQipYLf7a7NI",
        "wishlistId": "PDHZnhF8KRouKzWa",
        "url": "https://www.saxo.com/dk/street-food-derhjemme_katrine-klinken_haeftet_9788740058437?dfw_tracker=13098-78452492&gclid=CjwKCAiAuoqABhAsEiwAdSkVVMnXYO8ArHlA-E8nlIbPB_Br4dEbyY29ytCzsjG90Iv9h8FkQPW78RoC0EQQAvD_BwE",
        "createdAt": "2021-01-16T14:29:20.000Z",
        "quantity": 1,
        "productRef": {
            "id": "c2F4by5jb20vZGsvc3RyZWV0LWZvb2QtZGVyaGplbW1lX2thdHJpbmUta2xpbmtlbl9oYWVmdGV0Xzk3ODg3NDAwNTg0Mzd7aWQ6OnYxfURL",
            "uurl": "saxo.com/dk/street-food-derhjemme_katrine-klinken_haeftet_9788740058437",
            "countryCode": "DK",
            "originalUrl": "https://www.saxo.com/dk/street-food-derhjemme_katrine-klinken_haeftet_9788740058437?dfw_tracker=13098-78452492&gclid=CjwKCAiAuoqABhAsEiwAdSkVVMnXYO8ArHlA-E8nlIbPB_Br4dEbyY29ytCzsjG90Iv9h8FkQPW78RoC0EQQAvD_BwE",
            "domainName": "saxo.com",
            "createdAt": "2023-02-17T01:55:34.057Z",
            "updatedAt": "2023-02-17T01:55:34.057Z"
        }
    }
    "#;
    let data = serde_json::from_str::<Test::WishCreated>(json).unwrap();
    let schema = Test::WishCreated::get_schema();
    let data = apache_avro::to_value(data).unwrap();
    let mut data = apache_avro::to_avro_datum(&schema, data).unwrap();
    let data = apache_avro::from_avro_datum(&schema, &mut data.as_slice(), None)
        .unwrap();
    let data = apache_avro::from_value::<Test::WishCreated>(&data).unwrap();
    {
        ::std::io::_print(format_args!("Data {0:?}", data));
    };
}
